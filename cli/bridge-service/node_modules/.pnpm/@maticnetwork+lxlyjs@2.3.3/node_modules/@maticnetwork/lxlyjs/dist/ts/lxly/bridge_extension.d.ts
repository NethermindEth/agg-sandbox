import { BaseToken, Web3SideChainClient } from "../utils";
import { IBaseClientConfig, ITransactionOption } from "../interfaces";
import { TYPE_AMOUNT } from "../types";
export declare class BridgeExtension extends BaseToken<IBaseClientConfig> {
    networkID_: number;
    constructor(client_: Web3SideChainClient<IBaseClientConfig>, address: string, networkId: number);
    method(methodName: string, ...args: any[]): Promise<import("..").BaseContractMethod>;
    isEtherToken(): boolean;
    /**
     * bridge function to be called on that network from where token is to be transferred to a different network
     *
     * @param {string} token Token address
     * @param {TYPE_AMOUNT} amount amount of tokens
     * @param {number} destinationNetwork Network at which tokens will be bridged
     * @param {string} callAddress Address to which tokens will be bridged
     * @param {string} fallbackAddress Address to which tokens will be bridged if the execution fails.
     * @param {string} callData Encoded function data of the smart contract at target callAddress
     * @param {forceUpdateGlobalExitRoot} boolean boolean to force update global exit root
     * @param {string} permitData Permit data to avoid approve call
     * @param {ITransactionOption} [option]
     *
     * @returns
     * @memberof BridgeExtension
     */
    bridgeAndCall(token: string, amount: TYPE_AMOUNT, destinationNetwork: number, callAddress: string, fallbackAddress: string, calldata: string, forceUpdateGlobalExitRoot: boolean, permitData?: string, option?: ITransactionOption): Promise<import("..").ITransactionWriteResult>;
}
