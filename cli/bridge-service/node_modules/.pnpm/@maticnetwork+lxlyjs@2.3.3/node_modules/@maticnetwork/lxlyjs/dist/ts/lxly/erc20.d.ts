import { ITransactionOption } from "../interfaces";
import { Web3SideChainClient } from "../utils";
import { Token } from "./token";
import { TYPE_AMOUNT } from "../types";
import { ICargo, GassetSource, IConversionAuthorization } from '..';
import { IAllowanceTransactionOption, IApproveTransactionOption, IBridgeTransactionOption, IBaseClientConfig, IContracts } from "../interfaces";
export declare class ERC20 extends Token {
    private bridgeAdapter;
    constructor(tokenAddress: string, networkId: number, bridgeAdapterAddress: any, client: Web3SideChainClient<IBaseClientConfig>, getContracts: (networkId: number) => IContracts);
    /**
     * get bridge for that token
     *
     * @returns
     * @memberof ERC20
     */
    getBridgeAddress(): string;
    isEtherToken(): boolean;
    /**
     * get token balance of user
     *
     * @param {string} userAddress
     * @param {ITransactionOption} [option]
     * @returns
     * @memberof ERC20
     */
    getBalance(userAddress: string, option?: ITransactionOption): any;
    /**
     * is Approval needed to bridge tokens to other chains
     *
     * @returns
     * @memberof ERC20
     */
    isApprovalNeeded(): false | Promise<boolean>;
    /**
     * get allowance of user
     *
     * @param {string} userAddress
     * @param {ITransactionOption} [option]
     * @returns
     * @memberof ERC20
     */
    getAllowance(userAddress: string, option?: IAllowanceTransactionOption): Promise<string>;
    /**
     * Approve given amount of tokens for user
     *
     * @param {TYPE_AMOUNT} amount
     * @param {IApproveTransactionOption} [option]
     * @returns
     * @memberof ERC20
     */
    approve(amount: TYPE_AMOUNT, option?: IApproveTransactionOption): Promise<import("..").ITransactionWriteResult>;
    /**
     * Approve max amount of tokens for user
     *
     * @param {IApproveTransactionOption} [option]
     * @returns
     * @memberof ERC20
     */
    approveMax(option?: IApproveTransactionOption): Promise<import("..").ITransactionWriteResult>;
    /**
     * Bridge given amount of token for user
     *
     * @param {TYPE_AMOUNT} amount
     * @param {string} userAddress
     * @param {number} destinationNetworkId
     * @param {IBridgeTransactionOption} [option]
     * @returns
     * @memberof ERC20
     */
    bridgeAsset(amount: TYPE_AMOUNT, userAddress: string, destinationNetworkId: number, option?: IBridgeTransactionOption): Promise<import("..").ITransactionWriteResult>;
    /**
     * Bridge given amount of token for user along with ETH for gas token
     *
     * @param {TYPE_AMOUNT} amount
     * @param {string} userAddress
     * @param {number} destinationNetworkId
     * @param {IBridgeTransactionOption} [option]
     * @returns
     * @memberof ERC20
     */
    bridgeAssetWithGas(amount: TYPE_AMOUNT, userAddress: string, ethGasAmount: TYPE_AMOUNT, destinationNetworkId: number, option?: IBridgeTransactionOption): Promise<import("..").ITransactionWriteResult>;
    /**
     * Bridge given amount of token for user along with ETH for gas token
     *
     * @param {TYPE_AMOUNT} amount
     * @param {string} userAddress
     * @param {number} destinationNetworkId
     * @param {IBridgeTransactionOption} [option]
     * @returns
     * @memberof ERC20
     */
    bridgeAssetPermitWithGas(amount: TYPE_AMOUNT, userAddress: string, ethGasAmount: TYPE_AMOUNT, destinationNetworkId: number, option?: IBridgeTransactionOption): Promise<import("..").ITransactionWriteResult>;
    /**
     * Bridge given amount of token for user with permit call
     *
     * @param {TYPE_AMOUNT} amount
     * @param {string} userAddress
     * @param {number} destinationNetworkId
     * @param {IBridgeTransactionOption} [option]
     * @returns
     * @memberof ERC20
     */
    bridgeAssetWithPermit(amount: TYPE_AMOUNT, userAddress: string, destinationNetworkId: number, option?: IApproveTransactionOption): Promise<import("..").ITransactionWriteResult>;
    /**
     * Bridge asset to child chain using Custom ERC20 bridge Adapter
     * @param {TYPE_AMOUNT} amount
     * @param {string} userAddress
     * @param {number} destinationNetworkId
     * @param {boolean} forceUpdateGlobalExitRoot
     * @returns
     * @memberof ERC20
     */
    bridgeCustomERC20(amount: TYPE_AMOUNT, userAddress: string, destinationNetworkId: number, forceUpdateGlobalExitRoot?: boolean, option?: ITransactionOption): Promise<import("..").ITransactionWriteResult>;
    /**
     * Claim asset on child chain bridged using custom bridge adapter
     * @param {string} transactionHash
     * @param {number} sourceNetworkId
     * @param {ITransactionOption} option
     * @returns
     * @memberof ERC20
     */
    claimCustomERC20(transactionHash: string, sourceNetworkId: number, option?: ITransactionOption): any;
    /**
     * Claim Assets after GlobalExitRootManager is synced from source to destination
     *
     * @param {string} transactionHash
     * @param {number} sourceNetworkId
     * @param {ITransactionOption} [option]
     * @returns
     * @memberof ERC20
     */
    claimAsset(transactionHash: string, sourceNetworkId: number, option?: ITransactionOption): any;
    /**
     * Claim Assets after GlobalExitRootManager is synced from source to destination
     *
     * @param {string[]} smtProof Merkle Proof
     * @param {string[]} smtProofRollup Roll up Merkle Proof
     * @param {string} globalIndex Global Index
     * @param {string} mainnetExitRoot Mainnet Exit Root
     * @param {string} rollupExitRoot RollUP Exit Root
     * @param {number} originNetwork Network at which token was initially deployed
     * @param {string} originTokenAddress Address of token at network where token was initially deployed
     * @param {string} destinationAddress Address to which tokens will be bridged
     * @param {TYPE_AMOUNT} amount amount of tokens
     * @param {string} metadata Metadata of token
     * @param {ITransactionOption} [option]
     * @returns
     * @memberof ERC20
     */
    claimAssetRaw(smtProof: string[], smtProofRollup: string[], globalIndex: string, mainnetExitRoot: string, rollupExitRoot: string, originNetwork: number, originTokenAddress: string, destinationNetwork: number, destinationAddress: string, amount: TYPE_AMOUNT, metadata: string, option?: ITransactionOption): Promise<import("..").ITransactionWriteResult>;
    /**
     * transfer amount to another user
     *
     * @param {TYPE_AMOUNT} amount
     * @param {string} to
     * @param {ITransactionOption} [option]
     * @returns
     * @memberof ERC20
     */
    transfer(amount: TYPE_AMOUNT, to: string, option?: ITransactionOption): Promise<import("..").ITransactionWriteResult>;
    /**
     * get permitType of the token
     *
     * @returns
     * @memberof ERC20
     */
    private getPermit;
    /**
     * get typedData for signing
     * @param {string} permitType
     * @param {string} account
     * @param {number} chainId
     * @param {string} name
     * @param {string} nonce
     * @param {string} spenderAddress
     * @param {string} amount
     *
     * @returns
     * @memberof ERC20
     */
    private getTypedData_;
    /**
     * get {r, s, v} from signature
     * @param {BaseWeb3Client} client
     * @param {string} signature
     *
     * @returns
     * @memberof ERC20
     */
    private getSignatureParameters_;
    /**
     * encode permit function data
     * @param {BaseContract} contract
     * @param {string} permitType
     * @param {any} signatureParams
     * @param {string} spenderAddress
     * @param {string} account
     * @param {string} nonce
     * @param {string} amount
     *
     * @returns
     * @memberof ERC20
     */
    private encodePermitFunctionData_;
    private getPermitSignatureParams_;
    /**
     * Get permit data for given spender for given amount
     * @param {TYPE_AMOUNT} amount
     * @param {string} spenderAddress
     *
     * @returns
     * @memberof ERC20
     */
    private getPermitData_;
    /**
     * Get permit data for given amount
     * @param {TYPE_AMOUNT} amount
     * @param {IApproveTransactionOption} option
     *
     * @returns
     * @memberof ERC20
     */
    getPermitData(amount: TYPE_AMOUNT, option?: IApproveTransactionOption): Promise<any>;
    /**
     * Get the plot route call data for bridge asset and gas
     * @param {ICargo} cargo
     * @param {ITransactionOption} option
     *
     * @returns
     * @memberof ERC20
     */
    getPlotRoute(cargo: ICargo, option?: ITransactionOption): Promise<{
        bridgeAssetAndGas: {
            requestConversion: any;
            forceUpdateGlobalExitRoot: any;
            destinationNetwork: any;
            destinationAddress: any;
            trackingNumber: any;
            gasset: any;
            gassetSource: any;
            gassetPermitData: any;
            gassetAmount: any;
            swapCalldata: any;
            token: any;
            tokenAmount: any;
            tokenPermitData: any;
        };
        callData: any;
        msgValue: any;
    }>;
    /**
     * bridge asset and gas function
     * @param {boolean} requestConversion - It tells if the conversion is required on destination chain or not
     * @param {boolean} forceUpdateGlobalExitRoot
     * @param {number} destinationNetwork - the network on which the funds needs to be bridged
     * @param {string} destinationAddress - the address to which funds will be deposited
     * @param {string} gasset - address of the gas token
     * @param {GassetSource} gassetSource - the source of the gas token amount. it can be directly msg value, or dex swap or if user already has the ERC20 token then erc20.
     * @param {string} gassetPermitData - Permit data required to give permit to gasPorter for the gas token.
     * @param {string} gassetAmount - amount of gas token to be bridged
     * @param {string} swapCalldata - swap call data if swapping is required on the source chain
     * @param {string} token - token to be bridged
     * @param {string} tokenAmount - amount of token to be bridged
     * @param {string} tokenPermitData - Permit data required to give permit to gasPorter for the token to be bridged.
     * @param {ITransactionOption} option
     *
     * @returns
     * @memberof ERC20
     */
    bridgeAssetAndGas(requestConversion: boolean, forceUpdateGlobalExitRoot: boolean, destinationNetwork: number, destinationAddress: string, trackingNumber: number, gasset: string, gassetSource: GassetSource, gassetPermitData: string, gassetAmount: string, swapCalldata: string, token: string, tokenAmount: string, tokenPermitData: string, option?: ITransactionOption): Promise<import("..").ITransactionWriteResult>;
    /**
     * Get the plot route call data for bridge asset and gas and then do the bridgeAssetAndGas transaction
     * @param {ICargo} cargo
     * @param {ITransactionOption} option
     *
     * @returns
     * @memberof ERC20
     */
    bridgeAssetAndGasWithPlotRoute(cargo: ICargo, option?: ITransactionOption): Promise<import("..").ITransactionWriteResult>;
    convertGasset(data: IConversionAuthorization, signature: string, option?: ITransactionOption): Promise<import("..").ITransactionWriteResult>;
}
